
# File: concepts.txt

# https://tkdocs.com/tutorial/concepts.html

Widgets
=======
Widgets are things visible onscreen. (AKA Controls or Windows)
Individual widgets are objects, instances of classes that
represent buttons, frames, and so on.
To create a widget: need to identify its specific class and
its parent widget fitting it into a widow hierarchy, with a
single root at the top of the hierarchy.
Each widget is a Python object with a parent specified as its
first parameter. The only exception is the "root" window
automatically created when Tk is instantiated.
Whether or not you save the widget object in a variable is entirely
up to you, depending on whether you'll need to refer to it later.
All widgets have multiple (display or behavor) configuration options
with sensible defaults. Each has only a few configuration options that
are commonly used and which can be set at creation or set, reset or 
retrieved any time later (with few exceptions.)
Widgets can be queried for their supported options. See config.txt

Styles & Themes
===============
Appearance details have been moved into theme and style objects
which can be used as widget paramaters rather than individual params
for each widgit instance.
Themes collect a series of styles, putting all appearance decisions
in one place promoting consistency and improves reuse.

Widget Introspection
====================
Tk exposes information about each widget. Much of it is available via
the winfo facility; see the winfo command reference for full details.

    def print_hierarchy(w, depth=0):
        print('  '*depth + w.winfo_class() + ' w=' + 
                str(w.winfo_width()) + ' h=' + str(w.winfo_height()) +
                ' x=' + str(w.winfo_x()) + ' y=' + str(w.winfo_y()))
        for i in w.winfo_children():
            print_hierarchy(i, depth+1)

    print_hierarchy(root)

Some of the Most Useful Methods
-------------------------------
winfo_class: a class identifying the type of widget
winfo_children: a list of a widget's direct children
winfo_parent: parent of the widget
winfo_toplevel: the toplevel window containing this widget
winfo_width, winfo_height: current width and height of the widget
                not accurate until it appears onscreen
winfo_reqwidth, winfo_reqheight: requested width and height
winfo_x, winfo_y: the position of the top-left corner relative to its parent
winfo_rootx, winfo_rooty: displayed or hidden
        (to be viewable all ancestors must be viewable 

Geometry Management (on screen placement of widgets)
=================== --------------------------------
Simple creation of a widget does _not_ place it on the screen.
Grid: a geometry manager. (There are several in Tk.)
Note the parent/child (Master/Slave) relationships between widgets
and the recursive nature of changes.
Geometry manager parameters: eg row, column, sticky.

Event Handling
==============
Tk runs and manages an event loop that receives events from the OS:
button presses, keystrokes, mouse movements, window resizing, etc
Critical that the event loop not be blocked!  âˆ´ avoid long operations.
Responses to events can be customized by specifying a callback via a
widget comfiguration option. Callbacks call some other func or method.
For events that don't have a widget-specific callback configuration
option associated with them, you can use Tk's bind to capture any
event and then (like with callbacks) execute an arbitrary piece of
code. Callbacks call some other func or method.
For events that don't have a widget-specific callback configuration
option associated with them, you can use Tk's bind to capture any
event and then (like with callbacks) execute an arbitrary piece of
code. A (silly) example follows:
>>> from tkinter import *
>>> from tkinter import ttk
>>> root = Tk()
>>> l = ttk.Label(root, text="Starting...")
>>> l.grid()
>>> l.bind('<Enter>', lambda e: l.configure(text='Moved mouse inside'))
>>> l.bind('<Leave>', lambda e: l.configure(text='Moved mouse outside'))
>>> l.bind('<ButtonPress-1>', lambda e: l.configure(
                                      text='Clicked left mouse button'))
>>> l.bind('<3>', lambda e: l.configure(text='Clicked third mouse button'))
>>> l.bind('<Double-1>', lambda e: l.configure(text='Double clicked'))
>>> l.bind('<B3-Motion>', lambda e: l.configure(
                             text=f'third button drag to {e.x},{e.y}'))
>>> root.mainloop()

# see binding.py

Multiple Bindings for an Event
==============================
Up to now: event bindings assigned to a widget; matching event
triggers the binding.
A binding can capture not only a single event but a short sequence of
events. The <Double-1> binding triggered by 2 clicks.
Alternatively can use <KeyPress-a><KeyPress-b> or <a><b>.
Case matters! To bind to a capital A, use <KeyPress-A> or <A>.
Event bindings may be assigned to a parent window and will be
triggered when a matching event occurs anywhere in that widow.
Less commonly, you can create event bindings triggered when a
matching event occurs anywhere in the application or even for
events received by any widget of a given class, e.g., all buttons.
More than one binding can fire for an event keeping event handlers
concise and limited in scope, making for more modular code.
For example, the behavior of each widget class in Tk is itself defined
with script-level event bindings. These stay separate from event bindings
in your application. Event bindings assigned to a widget can also be
changed (or deleted) at any time. They can be modified to alter event
handling for widgets of a certain class or parts of your application.
You can reorder, extend, or change the sequence of event bindings that
are triggered for each widget; see the bindtags command reference
if you're curious. 

Available Events
================
The most common events are described below, along with the
circumstances when they are generated. Some are generated on some
platforms and not others. For a complete description see the
bind command reference.
<Activate>: Window has become active.
<Deactivate>: Window has been deactivated.
<MouseWheel>: Scroll wheel on mouse has been moved.
<KeyPress>: Key on keyboard has been pressed down.
<KeyRelease>: Key has been released.
<ButtonPress>: A mouse button has been pressed.
<ButtonRelease>: A mouse button has been released.
<Motion>: Mouse has been moved.
<Configure>: Widget has changed size or position.
<Destroy>: Widget is being destroyed.
<FocusIn>: Widget has been given keyboard focus.
<FocusOut>: Widget has lost keyboard focus.
<Enter>: Mouse pointer enters widget.
<Leave>: Mouse pointer leaves widget. 

Event details:
For mouse events: the button that was pressed, e.g., 1, 2, or 3.
For keyboard events, the specific key, e.g., A, 9, space, plus,
comma, equal. For a complete list: keysyms command reference.
Event modifiers can include:
B1 or Button1 to signify the main mouse button being held down,
Double or Triple for sequences of the same event.
Key modifiers for when keys on the keyboard are held down
inline Control, Shift, Alt, Option, and Command.

Virtual Event
=============
So far have dealt with low-level OS events: mouse clicks and window resizes.
Many widgets also generate higher-level, semantic events called virtual events
indicated by << >> around the event name, e.g., <<foo>>.
A <<ListboxSelect>> is generated when ever the listbox widget's
selection changes regardless how: user click, arrow key selection, etc
... no need to set up multiple event bindings to capture common changes.
See documentation for a widget class's available virtual events

Tk also defines virtual events such as <<Cut>>, <<Copy>> and <<Paste>>.
A <<ContextMenu>> virtual event is generated when the right mouse button
is clicked (to take care of macOS button discrepancy.)

You can define your own virtual events, possibly specific to your
application. i.e. to keep platform-specific details isolated in a single
module while using the virtual event throughout your application.

>>> root.event_generate("<<MyOwnEvent>>")

